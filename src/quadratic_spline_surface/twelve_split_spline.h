// Copyright 2023 Adobe Research. All rights reserved.
// To view a copy of the license, visit LICENSE.md.

#pragma once

#include "PS12_patch_coeffs.h"
#include "PS12tri_bounds_coeffs.h"
#include "common.h"
#include "quadratic_spline_surface.h"
#include "igl/per_vertex_normals.h"
#include "line_segment.h"
#include "polynomial_function.h"
#include "position_data.h"
#include "rational_function.h"

/// \file twelve_split_spline.h
///
/// Methods to generate a quadratic surface with twelve split Powell-Sabin basis
/// coefficients

/// A piecewise quadratic surface generated by twelve-split Powell-Sabin.
///
/// Supports:
/// - quadratic spline surface operations
/// - vertex position updates
class TwelveSplitSplineSurface : public QuadraticSplineSurface
{
public:
  /// Constructor for VF representation with uv coordinates and with additional
  /// data for the spline inferred as determined by the parameters.
  ///
  /// Maps from the input mesh faces to the patches and from patches to the
  /// faces are also generated.
  ///
  /// @param[in] V: mesh vertex positions
  /// @param[in] affine_manifold: affine manifold structure
  /// @param[in] optimization_params: parameters for the spline optimization
  /// @param[out] face_to_patch_indices: map from mesh faces to lists of
  /// corresponding patches
  /// @param[out] patch_to_face_indices: map from patches to the corresponding
  /// mesh face
  /// @param[out] fit_matrix: fit matrix for the energy
  /// @param[out] energy_hessian: hessian for the energy computation
  /// @param[out] energy_hessian_inverse: inverse of the hessian for the energy
  /// computation
  TwelveSplitSplineSurface(
    const Eigen::MatrixXd& V,
    const AffineManifold& affine_manifold,
    const OptimizationParameters& optimization_params,
    std::vector<std::vector<int>>& face_to_patch_indices,
    std::vector<int>& patch_to_face_indices,
    Eigen::SparseMatrix<double>& fit_matrix,
    Eigen::SparseMatrix<double>& energy_hessian,
    Eigen::CholmodSupernodalLLT<Eigen::SparseMatrix<double>>&
      energy_hessian_inverse);

  /// Constructor for the spline directly from position data.
  ///
  /// Maps from the input mesh faces to the patches and from patches to the
  /// faces are also generated.
  ///
  /// @param[in] corner_data: quadratic vertex position and derivative data
  /// @param[in] midpoint_data: quadratic edge midpoint derivative data
  /// @param[out] face_to_patch_indices: map from mesh faces to lists of
  /// corresponding patches
  /// @param[out] patch_to_face_indices: map from patches to the corresponding
  /// mesh face
  TwelveSplitSplineSurface(
    const std::vector<std::array<TriangleCornerFunctionData, 3>>& corner_data,
    const std::vector<std::array<TriangleMidpointFunctionData, 3>>&
      midpoint_data,
    std::vector<std::vector<int>>& face_to_patch_indices,
    std::vector<int>& patch_to_face_indices);

  /// Update the spline surface vertex positions for the fit
  ///
  /// @param[in] V: mesh vertex positions
  /// @param[out] fit_matrix: fit matrix for the energy
  /// @param[out] energy_hessian_inverse: inverse of the hessian for the energy
  /// computation
  void update_positions(
    const Eigen::MatrixXd& V,
    const Eigen::SparseMatrix<double>& fit_matrix,
    const Eigen::CholmodSupernodalLLT<Eigen::SparseMatrix<double>>&
      energy_hessian_inverse);

  /// Get the underlying affine manifold for the spline
  ///
  /// @return affine manifold for the spline
  AffineManifold const& get_affine_manifold() const
  {
    return m_affine_manifold;
  }

  /// Add the position data for the surface to the viewer
  void add_position_data_to_viewer() const;

  /// Clear the surface data.
  void clear();

  /// View the surface
  ///
  /// @param[in] color: color for the surface in the viewer
  /// @param[in] num_subdivisions: number of subdivisions for the surface
  virtual void view(Eigen::Matrix<double, 3, 1> color = SKY_BLUE,
                    int num_subdivisions = DISCRETIZATION_LEVEL) const;

private:
  void init_twelve_split_patches(
    const std::vector<std::array<TriangleCornerFunctionData, 3>>& corner_data,
    const std::vector<std::array<TriangleMidpointFunctionData, 3>>&
      midpoint_data,
    const std::vector<std::array<bool, 3>>& is_cone_corner,
    std::vector<std::vector<int>>& face_to_patch_indices,
    std::vector<int>& patch_to_face_indices);

  void generate_face_normals(const Eigen::MatrixXd& V,
                             const AffineManifold& affine_manifold,
                             Eigen::MatrixXd& N);

  AffineManifold m_affine_manifold;
  std::vector<std::array<TriangleCornerFunctionData, 3>> m_corner_data;
  std::vector<std::array<TriangleMidpointFunctionData, 3>> m_midpoint_data;
};

/// Generate patch boundary equations for the twelve split patches in the same
/// order as the patch surface mappings
///
/// @param[out] patch_boundaries: twelve patch domain boundary coefficients
void
generate_twelve_split_spline_patch_patch_boundaries(
  std::array<std::array<Eigen::Matrix<double, 3, 1>, 3>, 12>& patch_boundaries);

/// Generate a map from patches to corners of the face they correspond to, or
/// -1 for interior patches, and the vertex of the patch at the corner.
///
/// @param[out] patch_to_corner_map: face corner and patch vertex in the corner
/// for each patch
void
generate_twelve_split_spline_patch_patch_to_corner_map(
  std::array<std::pair<int, int>, 12>& patch_to_corner_map);

/// Generate areas for the twelve split patches in the same order as the
/// patch surface mappings for a given domain triangle.
///
/// @param[in] v0: first vertex position of the domain triangle
/// @param[in] v1: second vertex position of the domain triangle
/// @param[in] v2: third vertex position of the domain triangle
/// @param[out] patch_areas: twelve patch domain areas
void
generate_twelve_split_domain_areas(const PlanarPoint& v0,
                                   const PlanarPoint& v1,
                                   const PlanarPoint& v2,
                                   std::array<double, 12>& patch_areas);

/// Build matrices to go from position data to surface mappings
///
/// @param[out] coefficient_matrices: conversion matrix
template<typename Scalar>
void
generate_twelve_split_data_to_monomial_matrices(
  std::array<Eigen::Matrix<Scalar, 6, 12>, 12>& coefficient_matrices)
{
  double patch_coeffs[12][6][12];
  PS12_patch_coeffs(patch_coeffs);
  for (size_t i = 0; i < 12; ++i) {
    for (size_t j = 0; j < 6; ++j) {
      for (size_t k = 0; k < 12; ++k) {
        coefficient_matrices[i](j, k) = Scalar(patch_coeffs[i][j][k]);
      }
    }
  }
}

/// @param[in] F: mesh faces
/// @param[in] face_to_patch_indices: map from triangle mesh faces to the
/// patches arising from it
/// @param[out] patch_boundary_edges: edges of the patch triangle domains that
/// are boundaries
void
compute_twelve_split_spline_patch_boundary_edges(
  const Eigen::MatrixXi& F,
  const std::vector<std::vector<int>>& face_to_patch_indices,
  std::vector<std::pair<int, int>>& patch_boundary_edges);


/// Combine structured position data into a single matrix
///
/// @tparam Scalar: coefficient scalar
/// @param[in] corner_data: data at triangle corners
/// @param[in] midpoint_data: data at triangle edge midpoints
/// @param[out] twelve_split_data: combined data
template<typename Scalar>
void
generate_twelve_split_data_matrix(
  const std::array<TriangleCornerData<Eigen::Matrix<Scalar, 1, 3>>, 3>&
    corner_data,
  const std::array<TriangleMidpointData<Eigen::Matrix<Scalar, 1, 3>>, 3>&
    midpoint_data,
  Eigen::Matrix<Scalar, 12, 3>& twelve_split_data)
{
  // Vertex positions
  twelve_split_data.row(0) = corner_data[0].function_value;
  twelve_split_data.row(1) = corner_data[1].function_value;
  twelve_split_data.row(2) = corner_data[2].function_value;

  // Vertex gradients
  twelve_split_data.row(3) = corner_data[0].first_edge_derivative;
  twelve_split_data.row(4) = corner_data[0].second_edge_derivative;
  twelve_split_data.row(5) = corner_data[1].second_edge_derivative;
  twelve_split_data.row(6) = corner_data[1].first_edge_derivative;
  twelve_split_data.row(7) = corner_data[2].first_edge_derivative;
  twelve_split_data.row(8) = corner_data[2].second_edge_derivative;

  // Edge midpoint normals in order ij, jk, ki
  twelve_split_data.row(9) = midpoint_data[2].normal_derivative;
  twelve_split_data.row(10) = midpoint_data[0].normal_derivative;
  twelve_split_data.row(11) = midpoint_data[1].normal_derivative;
}

/// Generate twelve spline surface patch mapping coefficient matrix from corner
/// and midpoint data according to the twelve-split Powell-Sabin formula.
///
/// @tparam Scalar: coefficient scalar
/// @param[in] corner_data: data at triangle corners
/// @param[in] midpoint_data: data at triangle edge midpoints
/// @param[out] surface_mappings: spline surface mappings
template<typename Scalar>
void
generate_twelve_split_spline_patch_surface_mapping(
  const std::array<TriangleCornerData<Eigen::Matrix<Scalar, 1, 3>>, 3>&
    corner_data,
  const std::array<TriangleMidpointData<Eigen::Matrix<Scalar, 1, 3>>, 3>&
    midpoint_data,
  std::array<Eigen::Matrix<Scalar, 6, 3>, 12>& surface_mappings)
{
  // Generate matrices to go from the position data to surface coefficients
  std::array<Eigen::Matrix<Scalar, 6, 12>, 12> coefficient_matrices;
  generate_twelve_split_data_to_monomial_matrices<Scalar>(coefficient_matrices);

  // Combine position data into a matrix
  Eigen::Matrix<Scalar, 12, 3> twelve_split_data;
  generate_twelve_split_data_matrix<Scalar>(
    corner_data, midpoint_data, twelve_split_data);

  // Build the surface mappings
  for (size_t i = 0; i < 12; ++i) {
    surface_mappings[i] = coefficient_matrices[i] * twelve_split_data;
  }
}
